GNURadio \cite{gnuradioweb} is a set of free software \cite{fsffreeweb}
tools that are useful for building and simulating radio systems.
This chapter presents the anatomy of a GNURadio module.

\begin{subchapter}{GNURadio Companion}
  The first point of contact for most new GNURadio users
  is usually the \gls{grc}, a program that lets
  users design signal flowgraphs in a graphical way.
  \Gls{grc}'s main interface is shown in figure
  \ref{img:annotated_gnuradio_companion}, the flowgraph
  is an implementation of the \acrlong{schcox} detector block-diagram
  shown in figure \ref{img:sc_detector_blocks} in the previous
  chapter.

  \figurizefile{diagrams/annotated_gnuradio_companion.tex}
               {img:annotated_gnuradio_companion}
               {The \acrlong{grc}}
               {1}{h}

  When a flowgraph containing graphical instrumentation like
  the \texttt{QT GUI Time Sink} in figure \ref{img:annotated_gnuradio_companion}
  is executed, a window will open containing the output of
  the instruments.

  Figure \ref{img:gnuradio_gui} shows such a window, containing
  a \texttt{QT GUI Time Sink}, a GNURadio oscilloscope.

  \figurizegraphic{images/gnuradio_gui.png}
                  {img:gnuradio_gui}
                  {The graphical output of a running flowgraph}
                  {0.8}{h}

  \Gls{grc} works by generating a Python script from the
  graphical flowgraph representation, based on predefined
  patterns.

  A minimal flowgraph like the one shown in figure
  \ref{img:gnuradio_companion_minimal}, is translated
  to a Python script much like the one shown in
  listing \ref{lst:gnuradio_companion_minimal}
  (the code in the listing was edited for brevity
  as the autogenerated code is usually more verbose).

  When an user selects the \texttt{run} option in \gls{grc}
  the script will automatically be generated and executed,
  so that the user does not have to deal with any Python
  code while experimenting.

  \figurizegraphic{images/gnuradio_companion_minimal.png}
                  {img:gnuradio_companion_minimal}
                  {A minimal \gls{grc} flowgraph}
                  {0.6}{H}
\end{subchapter}

\begin{subchapter}{GNURadio native programming interfaces}
  While \gls{grc} is a great tool to experiment with signals,
  filters and prebuilt decoders, more advanced processing will
  often require writing processing blocks in, more flexible,
  textual programming languages.

  GNURadio provides two native interfaces to write own
  blocks in, C++ and Python 2\footnote{There is some work done
  in supporting Python 3, but as of the time of writing there is no
  mainline support for it.}.
  The Python interface has the benefit of being easier to program
  for while the C++ will usually provide better processing performance,
  as the code using it is compiled to native processor instructions.
  These tradeoffs should be considered when writing a
  new GNURadio processing block.

  \begin{subsubchapter}{Python-interface}
    Listing \ref{lst:gnuradio_companion_minimal} shows a block written
    in Python that does not perform its own signal processing but
    instead connects other blocks to produce a processing chain.

    The block is derived from the \texttt{gr.top\_block} base class,
    as can be seen in line \texttt{5}. Blocks derived from this base class
    do not expose any input or output ports and do not perform their own
    signal processing, instead they are used to hierarchically connect
    other blocks to form a graph.
    A typical GNURadio program will contain one top block that is
    used to connect the signal processing chain.

    There are also some other base classes from which GNURadio
    blocks can be derived\cite{grblockscodingguide}:

    \begin{description}
      \item[\texttt{gr.sync\_block}]
        A block that, for every input item, will produce exactly
        one output item. This can, for example, be a block that,
        for a stream of complex input symbols, outputs the real
        magnitude of each symbol.

        Or the multiply block, as seen in figure
        \ref{img:gnuradio_companion_minimal}, which will produce one
        output symbol for each input symbol present at both inputs.

      \item[\texttt{gr.sync\_decimator}]
        Decimator blocks are quite similar to sync blocks,
        but will produce output items at lower rate than input items
        are consumed.

        The relative input and output rate has to be fixed.

        One example would be a block that takes two consecutive input
        items, adds them and outputs them as a single output item.

        Decimator blocks are especially useful for
        sample rate reducing filters.

      \item[\texttt{gr.sync\_interpolator}]
        Interpolator blocks are the rate-increasing pendant
        to decimator blocks.

      \item[\texttt{gr.block}]
        \texttt{Gr.block} is the base class for every other class
        in this list, as it is the most generic block type.

        Thise base class does not impose any rate restrictions
        on the block, allowing for greater flexibility when
        programming a block derived from this base class.

        There is however some more housekeeping work to be
        done that can no longer be handled automatically when
        choosing this block instead of the more restricted base classes,
        to keep the processing efficient.

      \item[\texttt{gr.hier\_block2}]
        Blocks derived from this base class are pureley
        hierarchical, they do not perform any signal processing
        themselve but instead combine other blocks to perform
        signal processing on the hierarchical block's inputs and
        output the results on the hierarchical block's outputs.

      \item[\texttt{gr.top\_block}]
        The top block, as discussed earlier, is a special kind of
        hierarchical block that does not provide any inputs or outputs.

        Instead it contains some additional functionality to execute
        the contained flowgraph.
    \end{description}

    The rest of listing \ref{lst:gnuradio_companion_minimal}
    performs the equivalent of the flowgraph in figure
    \ref{img:gnuradio_companion_minimal}.

    Lines \texttt{10} to \texttt{19} create instances of the
    blocks used in the flowgraph and provide them with the
    correct parameters like sample rate and frequency.

    Lines \texttt{22} to \texttt{24} create the connections
    between the blocks that were previously instanciated.

    Lines \texttt{27} to \texttt{31} create an instance of the
    top block and execute it until the enter key is pressed
    on the terminal.

    \lstinputlisting[numbers=left, basicstyle=\scriptsize,
                     numbersep=5pt, language=Python,
                     caption=Using GNURadio from Python,
                     label=lst:gnuradio_companion_minimal,
                     captionpos=b, float]
                    {listings/gnuradio_companion_minimal.py}

  \end{subsubchapter}

  \begin{subsubchapter}{C++-Interface}
    Most of GNURadio's backend code is not written in Python
    but in C++, as it provides lower level access to the computer
    memory and better computing performance. \\

    A lot of this backend code can be acessed from Python
    thanks to C++-to-Python wrappers that are automatically
    generated using the SWIG \cite{swigweb} software tool.

    One example of C++ code for which wrappers are available
    are the, previously discussed, \texttt{gr.*\_block} block
    base classes which are actually implemented in C++
    but can also be used to derive blocks from in python. \\

    Accordingly custom blocks can also be implemented in
    C++, as demonstrated in listing \ref{lst:square_cc}.
    The block shown is derived from the \texttt{gr:sync\_block}
    base class, as can be seen in line \texttt{14}, as
    such it is bound to produce one output item
    per input item consumed at its input. \\

    The input (line \texttt{15}) and output (line \texttt{16})
    signature specifiers specify the number of input and output
    ports of the block and their type.
    The simple input signature

    \begin{center}
      \texttt{gr::io\_signature::make(1, 1, sizeof(float))}
    \end{center}

    breaks down to: ``This block has at least one input port '\texttt{1,}' and
    at most one input port '\texttt{1,}' an input item consists of a single real
    number '\texttt{sizeof(float)}' ''.

    Thus the block will have exactly one real-valued input port and exactly
    one real-valued output port. \\

    \lstinputlisting[numbers=left, basicstyle=\scriptsize,
                     numbersep=5pt, language=C++,
                     caption=A simple custom block in C++,
                     label=lst:square_cc,
                     captionpos=b, float]
                    {listings/square.cc}

    The actual signal processing for the demonstrated block
    is performed in the \texttt{work} method, starting in line
    \texttt{29}. The work method is passed the following arguments
    by the underlying GNURadio logic:

    \begin{description}
      \item[\texttt{noutput\_items}]
        The number of output items the block should write to the output
        buffers in this iteration, as this is a sync block this is also
        the minimum number of input items that are available in the input buffers.

      \item[\texttt{input\_items}]
        A list of input buffers. In this case the list only contains
        a single reference to an input buffer as there is only a
        single input port.

      \item[\texttt{output\_items}]
        A list of output buffers. Again, in the case at hand,
        this will only contain a single reference.
    \end{description}
  \end{subsubchapter}

  In the \texttt{for}-loop starting in line \texttt{32}
  every element in the input buffer is squared and written to
  the corresponding position in the output buffer.

  In line \texttt{36} the number of items that were actually consumed
  is returned, in this case it is equal to the number of items
  the method was requested to produce.
\end{subchapter}

\begin{subchapter}{GNURadio Internals}
  As the code samples in listings \ref{lst:gnuradio_companion_minimal}
  and \ref{lst:square_cc} showed, GNURadio blocks do not have to
  perform any buffer management themselves to handle the streaming
  input and output ports. \\

  The buffer management and scheduling of when to execute the processing
  block is instead handled internally by GNURadio.
  As the processing blocks are only allowed to communicate with
  other blocks using the previously discussed input and output ports
  and a, not yet discussed, message passing interface they can also
  be executed concurrently on multiple CPU cores by the GNURadio scheduler
  without having to fear race conditions on shared data. \\

  \begin{subsubchapter}{Buffer management and Scheduling}
    \figurizegraphic{images/gnuradio_companion_bufferdemo.png}
                    {img:gnuradio_companion_bufferdemo}
                    {A minimal flowgraph to demonstrate buffer management}
                    {0.6}{H}

    For a flowgraph as shown in figure \ref{img:gnuradio_companion_bufferdemo}
    GNURadio will allocate two internal buffers, one for the ``Signal Source'' block
    to write into and the ``Multiply Const'' block to read from and one for the
    ``Multiply Const'' block to write into and the ``Null Sink'' block to
    read from \cite{grblogbuffers}. \\

    In the following diagrams the first buffer will be called ``Buffer A''
    and the second buffer will be called ``Buffer B''.
    The buffers in GNURadio are organized as circular buffers, this means
    that size of the occupied memory region remains constant during execution
    and that there is one pointer into the memory region where the next
    values should be written (\texttt{write\_ptr}) and one or more
    pointers pointing to the next value to be read (\texttt{read\_ptr}). \\

    If both pointers point to the same position the buffer is empty.
    If a pointer is incremented past the end of the memory region
    it wraps around to the beginning. \\

    Figure \ref{img:gr_round_buffers_a} shows the initial state of the
    two buffers in the current example, right when the execution of the
    flow graph starts.
    In both buffers \texttt{write\_ptr} and \texttt{read\_ptr}
    point to the same location, the beginning of the buffers,
    so both buffers are empty.

    \figurizefile{diagrams/gr_round_buffers_a.tex}
                 {img:gr_round_buffers_a}
                 {Initial state of the two buffers}
                 {0.7}{H}

    The GNURadio scheduler tries to keep all the buffers filled
    and will execute blocks until every buffer is full.
    Blocks that depend on input to process like the ``Multiply Const''
    or ``Null Sink'' block in the example cannot be executed
    unless there is data in their input buffers. \\

    To determine which block to execute next the scheduler
    asks every block, which does not have a completely filled
    output buffer, to estimate how many input items it needs to fill
    its output buffers. \\

    For synchronous blocks, like the ``Multiply Const'' block,
    this corresponds to a simple 1:1 mapping, as the block
    needs $n$ input values to produce $n$ output values. \\

    Blocks without output ports, like the ``Null Sink'' block,
    can be scheduled whenever there is data in their input
    buffers.
    Blocks without input ports, like ``Signal Source'' can
    always be scheduled, but might not actually produce the
    desired number of output values, for example when a
    hardware device did not produce enough samples. \\

    In the example the scheduler asks the ``Multiply Const''
    block how many input items it will need to fill the
    its output buffer of length $n_0$, the block answers with
    $n_0$ items.
    The scheduler can not provide that many input items,
    as the input buffer is empty.
    The scheduler will then sucessively halve the number
    of output items it requests $n_{i+1}=n_i/2$ util
    it determines that it can not fulfill the blocks
    input requirements. \\

    The scheduler then determines that the ``Signal Source''
    block can be executed, as it does not depend on any
    inputs.
    The ``Signal Source'' is executed and produces some
    output values that it puts into ``Buffer A'', it is assumed
    that the block was not able to fill the complete buffer.
    The states of the buffers after the ``Signal Source''
    block is executed is shown in figure \ref{img:gr_round_buffers_b}. \\

    The diagram shows some valid data in ``Buffer A'' that was
    not yet consumed, ``Buffer B'' remains empty.

    \figurizefile{diagrams/gr_round_buffers_b.tex}
                 {img:gr_round_buffers_b}
                 {Buffer states after ``Signal Source'' was executed}
                 {0.7}{H}

    \figurizefile{diagrams/gr_round_buffers_c.tex}
                 {img:gr_round_buffers_c}
                 {Buffer states after ``Multiply Const'' was executed}
                 {0.7}{H}

    \figurizefile{diagrams/gr_round_buffers_d.tex}
                 {img:gr_round_buffers_d}
                 {Buffer states after ``Null Sink'' was executed}
                 {0.7}{H}

  \end{subsubchapter}

  \begin{subsubchapter}{Efficient circular buffers}
  \end{subsubchapter}
\end{subchapter}
