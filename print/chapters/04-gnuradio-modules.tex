GNU Radio \cite{gnuradioweb} is a set of free software \cite{fsffreeweb}
tools that are useful for building and simulating radio systems on
generic computer hardware.
This chapter presents GNU Radio in general, the different interfaces
to GNU Radio and the anatomy of a GNU Radio module.

\begin{subchapter}{GNU Radio Companion}
  The first point of contact for most new GNU Radio users
  is usually the \gls{grc}, a program that lets
  users design signal flowgraphs in a graphical way.
  \Gls{grc}'s main interface is shown in
  \autoref{img:annotated_gnuradio_companion}, the flowgraph presented
  in this figure is an implementation of the
  \acrlong{schcox} detector block-diagram
  shown in figure \ref{img:sc_detector_blocks} in the previous
  chapter.

  \figurizefile{diagrams/annotated_gnuradio_companion.tex}
               {img:annotated_gnuradio_companion}
               {The \acrlong{grc}}
               {1}{h}

  When a flowgraph containing graphical instrumentation like
  the \texttt{QT GUI Time Sink} in figure \ref{img:annotated_gnuradio_companion}
  is executed, a window opens containing the output of
  these instruments.
  \autoref{img:gnuradio_gui} shows such a window, containing
  a \texttt{QT GUI Time Sink}, a GNU Radio oscilloscope. \\

  \figurizegraphic{images/gnuradio_gui.png}
                  {img:gnuradio_gui}
                  {The graphical output of a running flowgraph}
                  {0.8}{h}

  \Gls{grc} works by generating a
  Python script\footnote{Python is an interpreted progamming language}
  from the
  graphical flowgraph representation, based on predefined
  patterns.

  A minimal flowgraph like the one shown in figure
  \ref{img:gnuradio_companion_minimal}, is translated
  to a Python script
  much like the one shown in
  listing \ref{lst:gnuradio_companion_minimal}
  (the code in the listing is edited for brevity
  as the autogenerated code is usually more verbose).

  When an user selects the \texttt{run} option in \gls{grc}
  a script is automatically be generated and executed,
  so that the user does not have to deal with any Python
  code while experimenting.

  \figurizegraphic{images/gnuradio_companion_minimal.png}
                  {img:gnuradio_companion_minimal}
                  {A minimal \gls{grc} flowgraph}
                  {0.6}{H}
\end{subchapter}

\begin{subchapter}{GNU Radio native programming interfaces}
  While \gls{grc} is a great tool to experiment with signals,
  filters and prebuilt decoders, more advanced processing
  often requires writing custom processing blocks in, more flexible,
  textual programming languages. \\

  GNU Radio provides two native interfaces to write custom
  blocks in, C++ and Python 2\footnote{There is some work done
  in supporting Python 3, but as of the time of writing there is no
  mainline support for it.}.
  The Python interface has the benefit of being easier to program
  for, while the C++ will usually provide better processing performance,
  as the code using it is compiled to native processor instructions.
  These tradeoffs have to be considered when writing a
  new GNU Radio processing block.

  \begin{subsubchapter}{Python-interface}
    Listing \ref{lst:gnuradio_companion_minimal} shows a block written
    in Python that does not perform its own signal processing but
    instead connects other blocks to produce a processing chain.

    The block is derived from the \texttt{gr.top\_block} base class,
    as can be seen in line \texttt{5}. Blocks derived from this base class
    do not expose any input or output ports and do not perform their own
    signal processing, instead they are used to hierarchically connect
    other blocks to form a processing graph.
    A typical GNU Radio program will contain one top block that is
    used to setup the signal processing chain.

    There are also some other base classes from which GNU Radio
    blocks can be derived\cite{grblockscodingguide}:

    \begin{description}
      \item[\texttt{gr.sync\_block}]
        A block that, for every input item, will produce exactly
        one output item. This can, for example, be a block that,
        for a stream of complex input symbols, outputs the real
        magnitude of each symbol.

        Or the multiply block, as seen in figure
        \ref{img:gnuradio_companion_minimal}, which will produce one
        output symbol for each input symbol present at both inputs.

      \item[\texttt{gr.sync\_decimator}]
        Decimator blocks are quite similar to sync blocks,
        but will produce output items at lower rate than input items
        are consumed.

        The relative input and output rate has to be fixed at runtime.

        One example would be a block that takes two consecutive input
        items, adds them and outputs them as a single output item.

        Decimator blocks are especially useful for
        sample rate reducing filters.

      \item[\texttt{gr.sync\_interpolator}]
        Interpolator blocks are the rate-increasing pendant
        to decimator blocks.

      \item[\texttt{gr.block}]
        \texttt{Gr.block} is the base class for every other class
        in this list, as it is the most generic block type.

        Thise base class does not impose any rate restrictions
        on the block, allowing for greater flexibility when
        programming a block derived from this base class.

        There is however some more housekeeping work to be
        done that can no longer be handled automatically when
        choosing this block instead of the more restricted base classes,
        to keep the processing efficient.

      \item[\texttt{gr.hier\_block2}]
        Blocks derived from this base class are pureley
        hierarchical, they do not perform any signal processing
        themselve but instead combine other blocks to perform
        signal processing on the hierarchical block's inputs and
        output the results on the hierarchical block's outputs.

      \item[\texttt{gr.top\_block}]
        The top block, as discussed earlier, is a special kind of
        hierarchical block that does not provide any inputs or outputs.

        Instead it contains some additional functionality to execute
        the contained flowgraph.
    \end{description}

    The rest of listing \ref{lst:gnuradio_companion_minimal}
    performs the equivalent of the flowgraph in figure
    \ref{img:gnuradio_companion_minimal}.

    Lines \texttt{10} to \texttt{19} create instances of the
    blocks used in the flowgraph and provide them with the
    correct parameters like sample rate and frequency.
    Lines \texttt{22} to \texttt{24} create the connections
    between the blocks that were previously instanciated.
    Lines \texttt{27} to \texttt{31} create an instance of the
    top block and execute it until the enter key is pressed
    on the terminal.

    \lstinputlisting[numbers=left, basicstyle=\scriptsize,
                     numbersep=5pt, language=Python,
                     caption=Using GNU Radio from Python,
                     label=lst:gnuradio_companion_minimal,
                     captionpos=b, float]
                    {listings/gnuradio_companion_minimal.py}

  \end{subsubchapter}

  \begin{subsubchapter}{C++-Interface}
    Most of GNU Radio's backend code is not written in Python
    but in C++, as it provides lower level access to the computer
    memory and better computing performance. \\

    A lot of this backend code can be acessed from Python
    thanks to C++-to-Python wrappers that are automatically
    generated using the SWIG \cite{swigweb} software tool.

    One example of C++ code for which wrappers are available
    are the, previously discussed, \texttt{gr.*\_block} block
    base classes which are actually implemented in C++
    but can also be used to derive blocks from in Python. \\

    Accordingly custom blocks can also be implemented in
    C++, as demonstrated in listing \ref{lst:square_cc}.
    The block shown is derived from the \texttt{gr:sync\_block}
    base class, as can be seen in line \texttt{14}, as
    such it is bound to produce one output item
    per input item consumed at its input. \\

    The input (line \texttt{15}) and output (line \texttt{16})
    signature specifiers specify the number of input and output
    ports of the block and their type.
    The simple input signature

    \begin{center}
      \texttt{gr::io\_signature::make(1, 1, sizeof(float))}
    \end{center}

    breaks down to: ``This block has at least one input port '\texttt{1,}' and
    at most one input port '\texttt{1,}' an input item consists of a single real
    number '\texttt{sizeof(float)}' ''.

    Thus the block will have exactly one real-valued input port and exactly
    one real-valued output port. \\

    \lstinputlisting[numbers=left, basicstyle=\scriptsize,
                     numbersep=5pt, language=C++,
                     caption=A simple custom block in C++,
                     label=lst:square_cc,
                     captionpos=b, float]
                    {listings/square.cc}

    The actual signal processing for the demonstrated block
    is performed in the \texttt{work} method, starting in line
    \texttt{29}. The work method is passed the following arguments
    by the underlying GNU Radio logic:

    \begin{description}
      \item[\texttt{noutput\_items}]
        The number of output items the block should write to the output
        buffers in this iteration, as this is a sync block this is also
        the minimum number of input items that are available in the input buffers.

      \item[\texttt{input\_items}]
        A list of input buffers. In this case the list only contains
        a single reference to an input buffer as there is only a
        single input port.

      \item[\texttt{output\_items}]
        A list of output buffers. Again, in the case at hand,
        this will only contain a single reference.
    \end{description}
  \end{subsubchapter}

  In the \texttt{for}-loop starting in line \texttt{32}
  every element in the input buffer is squared and written to
  the corresponding position in the output buffer.

  In line \texttt{36} the number of items that were actually consumed
  is returned, in this case it is equal to the number of items
  the method was requested to produce.
\end{subchapter}
